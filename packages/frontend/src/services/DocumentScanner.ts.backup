import jscanify from 'jscanify';

// Declare global cv variable for OpenCV.js
declare const cv: any;

// A promise that resolves when OpenCV.js is fully initialized
export const cvReadyPromise = new Promise<void>((resolve) => {
  if (typeof cv !== 'undefined' && cv.onRuntimeInitialized) {
    cv.onRuntimeInitialized = () => {
      console.log("OpenCV.js is ready!");
      resolve();
    };
  } else {
    // If already initialized or not loaded, check periodically or resolve immediately if possible
    const checkCv = () => {
      if (typeof cv !== 'undefined' && cv.onRuntimeInitialized) {
        if (cv.Mat) { // Check if a core class exists, indicating readiness
          console.log("OpenCV.js already ready!");
          resolve();
        } else {
          cv.onRuntimeInitialized = () => { // Ensure our callback is set if it's not yet initialized
            console.log("OpenCV.js is ready!");
            resolve();
          };
        }
      } else {
        setTimeout(checkCv, 100); // Re-check after a short delay
      }
    };
    checkCv();
  }
});

/**
 * Processes a receipt image to crop, de-warp, and enhance it for OCR/readability.
 * 
 * @param imageElement The source HTMLImageElement containing the receipt.
 * @returns A HTMLCanvasElement containing the processed image.
 * @throws Error if OpenCV is not loaded or not initialized.
 */
export const processReceipt = async (imageElement: HTMLImageElement): Promise<HTMLCanvasElement> => {
  // Ensure OpenCV.js is loaded and initialized
  if (typeof cv === 'undefined') {
    throw new Error("OpenCV.js is not loaded. Ensure the script tag is present and accessible.");
  }
  await cvReadyPromise; // Wait for OpenCV to signal its readiness

  const scanner = new jscanify();

  // 1. Identification & Crop
  // extractPaper returns a canvas with the cropped, un-warped image
  // We use the full natural dimensions of the image for best quality
  const croppedCanvas = scanner.extractPaper(imageElement, imageElement.naturalWidth, imageElement.naturalHeight);
  
  // 2. Enhancement (Pre-processing for OCR)
  // We need to convert the canvas back to an OpenCV Matrix to process it
  const srcMat = cv.imread(croppedCanvas);
  const dstMat = new cv.Mat();
  
  // A. Convert to Grayscale (OCR engines prefer 1 channel)
  cv.cvtColor(srcMat, srcMat, cv.COLOR_RGBA2GRAY, 0);

  // B. Adaptive Thresholding
  // This turns the image black and white based on local pixel neighborhoods, 
  // effectively killing shadows and boosting text contrast.
  // Block size (21) and C (10) are tuned for typical receipts based on example.
  cv.adaptiveThreshold(
    srcMat, 
    dstMat, 
    255, 
    cv.ADAPTIVE_THRESH_GAUSSIAN_C, 
    cv.THRESH_BINARY, 
    21, 
    10
  );

  // 3. Render back to canvas
  cv.imshow(croppedCanvas, dstMat);

  // Cleanup OpenCV memory (Crucial!)
  srcMat.delete();
  dstMat.delete();

  return croppedCanvas;
};
