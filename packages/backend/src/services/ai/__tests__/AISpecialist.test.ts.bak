import { AISpecialist } from '../AISpecialist';
import fs from 'fs';
// Don't import GoogleGenerativeAI directly here when using explicit factory mock

const pdf = require('pdf-parse');

// Mock external dependencies
jest.mock('fs');
jest.mock('pdf-parse', () => jest.fn());

// Create the mock for GoogleGenerativeAI class
const mockGoogleGenerativeAI = jest.fn(); // This will be the mocked class constructor
const mockGetGenerativeModel = jest.fn();
const mockGenerateContent = jest.fn();

jest.mock('@google/generative-ai', () => ({
  GoogleGenerativeAI: mockGoogleGenerativeAI, // Assign our mock to the named export
}));


describe('AISpecialist', () => {
  let aiSpecialist: AISpecialist;

  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks(); // This will clear mockGoogleGenerativeAI, mockGetGenerativeModel, mockGenerateContent

    // Configure the mock implementation for this test run
    mockGoogleGenerativeAI.mockImplementation(() => ({
      getGenerativeModel: mockGetGenerativeModel,
    }));
    mockGetGenerativeModel.mockReturnValue({
      generateContent: mockGenerateContent,
    });
    mockGenerateContent.mockResolvedValue({
      response: {
        text: () => 'Gemini Response',
      },
    });

    process.env.GEMINI_API_KEY = 'mock-api-key';

    aiSpecialist = new AISpecialist();
  });

  afterEach(() => {
    delete process.env.GEMINI_API_KEY;
  });

  it('should be defined', () => {
    expect(aiSpecialist).toBeDefined();
  });

  it('should process a request using Gemini when API key is present', async () => {
    const prompt = 'Generate a strategy';
    const response = await aiSpecialist.processRequest({ prompt });

    expect(response.content).toBe('Gemini Response');
    expect(response.metadata?.model).toBe('gemini-2.0-flash');
    expect(mockGoogleGenerativeAI).toHaveBeenCalledWith('mock-api-key');
    expect(mockGetGenerativeModel).toHaveBeenCalledWith({ model: 'gemini-2.0-flash', systemInstruction: expect.any(String) });
    expect(mockGenerateContent).toHaveBeenCalled();
  });

  it('should fallback to mock response if API key is missing', async () => {
    delete process.env.GEMINI_API_KEY;
    // Re-instantiate to trigger constructor check
    const localSpecialist = new AISpecialist();
    
    const prompt = 'Generate a strategy';
    const response = await localSpecialist.processRequest({ prompt });

    expect(response.content).toContain(`[AI Response]: ${prompt}`);
    expect(response.metadata?.model).toBe('mock-model-v2');
  });

  it('should fallback to mock response if Gemini API fails', async () => {
    mockGenerateContent.mockRejectedValue(new Error('API Error'));

    const prompt = 'Generate a strategy';
    const response = await aiSpecialist.processRequest({ prompt });

    expect(response.content).toContain('[Error interacting with AI Provider]');
    expect(response.content).toContain(`[AI Response]: ${prompt}`);
  });

  it('should extract text from a PDF and include it in the prompt sent to Gemini', async () => {
    const mockPdfText = 'This is content from a PDF.';
    (fs.readFileSync as jest.Mock).mockReturnValue(Buffer.from('fake-pdf-data'));
    (pdf as jest.Mock).mockResolvedValue({ text: mockPdfText });

    const prompt = 'Analyze PDF';
    await aiSpecialist.processRequest({
      prompt,
      files: [{ path: 'test.pdf', mimeType: 'application/pdf' }]
    });

    expect(mockGenerateContent).toHaveBeenCalledWith({
        contents: expect.arrayContaining([
            expect.objectContaining({ text: expect.stringContaining(prompt) }),
            expect.objectContaining({ text: expect.stringContaining(mockPdfText) }),
        ]),
        generationConfig: undefined,
    });
  });
  
  it('should include additional context in the prompt', async () => {
    const prompt = 'Refine this';
    const context = { previousAttempt: 'failed', score: 10 };
    await aiSpecialist.processRequest({ prompt, context });
    
    expect(mockGenerateContent).toHaveBeenCalledWith({
        contents: expect.arrayContaining([
            expect.objectContaining({ text: expect.stringContaining(prompt) }),
            expect.objectContaining({ text: expect.stringContaining(JSON.stringify(context, null, 2)) }),
        ]),
        generationConfig: undefined,
    });
  });
});
